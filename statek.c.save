#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#include <time.h>
#include <string.h>


#define SHM_KEY1 12345
#define SHM_KEY2 12346
#define SEM_KEY1 22345
#define SEM_KEY2 22346
#define FIFO_PATH1 "./fifo_boat1"
#define FIFO_PATH2 "./fifo_boat2"
#define BOAT1_CAPACITY 70
#define BOAT2_CAPACITY 50
#define TIMEOUT 20  // 20 minutes without passengers
#define TRIP_TIME 120 // 2 hours trip time

struct boat_state {
    int occupied_seats;
    pid_t passengers[70]; // Max capacity for boat 1
};

int shmid1, shmid2;
int semid1, semid2;
struct boat_state *boat1, *boat2;

void cleanup(int signum) {
    printf("\nZwalnianie zasob\u00f3w...\n");

    // Zabijanie proces\u00f3w potomnych
    printf("Zabijam procesy potomne...\n");
    kill(0, SIGTERM);

    // Od\u0142\u0105czanie pami\u0119ci wsp\u00f3\u0142dzielonej dla \u0142odzi 1
    if (boat1 != NULL && shmdt(boat1) == -1) {
        perror("Nie uda\u0142o si\u0119 od\u0142\u0105czy\u0107 pami\u0119ci wsp\u00f3\u0142dzielonej dla \u0142odzi 1");
    } else {
        printf("Pami\u0119\u0107 wsp\u00f3\u0142dzielona dla \u0142odzi 1 zosta\u0142a od\u0142\u0105czona.\n");
    }

    // Usuwanie pami\u0119ci wsp\u00f3\u0142dzielonej dla \u0142odzi 1
    if (shmid1 != -1 && shmctl(shmid1, IPC_RMID, NULL) == -1) {
        perror("Nie uda\u0142o si\u0119 usun\u0105\u0107 pami\u0119ci wsp\u00f3\u0142dzielonej dla \u0142odzi 1");
    } else {
        printf("Pami\u0119\u0107 wsp\u00f3\u0142dzielona dla \u0142odzi 1 zosta\u0142a usuni\u0119ta.\n");
    }

    // Od\u0142\u0105czanie pami\u0119ci wsp\u00f3\u0142dzielonej dla \u0142odzi 2
    if (boat2 != NULL && shmdt(boat2) == -1) {
        perror("Nie uda\u0142o si\u0119 od\u0142\u0105czy\u0107 pami\u0119ci wsp\u00f3\u0142dzielonej dla \u0142odzi 2");
    } else {
        printf("Pami\u0119\u0107 wsp\u00f3\u0142dzielona dla \u0142odzi 2 zosta\u0142a od\u0142\u0105czona.\n");
    }

    // Usuwanie pami\u0119ci wsp\u00f3\u0142dzielonej dla \u0142odzi 2
    if (shmid2 != -1 && shmctl(shmid2, IPC_RMID, NULL) == -1) {
        perror("Nie uda\u0142o si\u0119 usun\u0105\u0107 pami\u0119ci wsp\u00f3\u0142dzielonej dla \u0142odzi 2");
    } else {
        printf("Pami\u0119\u0107 wsp\u00f3\u0142dzielona dla \u0142odzi 2 zosta\u0142a usuni\u0119ta.\n");
    }

    // Usuwanie semafor\u00f3w
    if (semid1 != -1 && semctl(semid1, 0, IPC_RMID) == -1) {
        perror("Nie uda\u0142o si\u0119 usun\u0105\u0107 semafora dla \u0142odzi 1");
    } else {
        printf("Semafor dla \u0142odzi 1 zosta\u0142 usuni\u0119ty.\n");
    }
    if (semid2 != -1 && semctl(semid2, 0, IPC_RMID) == -1) {
        perror("Nie uda\u0142o si\u0119 usun\u0105\u0107 semafora dla \u0142odzi 2");
    } else {
        printf("Semafor dla \u0142odzi 2 zosta\u0142 usuni\u0119ty.\n");
    }

    // Usuwanie plik\u00f3w FIFO
    if (unlink(FIFO_PATH1) == 0) {
        printf("Plik FIFO dla \u0142odzi 1 zosta\u0142 usuni\u0119ty.\n");
    } else {
        perror("Nie uda\u0142o si\u0119 usun\u0105\u0107 pliku FIFO dla \u0142odzi 1");
    }
    if (unlink(FIFO_PATH2) == 0) {
        printf("Plik FIFO dla \u0142odzi 2 zosta\u0142 usuni\u0119ty.\n");
    } else {
        perror("Nie uda\u0142o si\u0119 usun\u0105\u0107 pliku FIFO dla \u0142odzi 2");
    }
    printf("Zasoby zosta\u0142y zwolnione.\n");
    exit(0);
}

void init_shared_memory() {
    shmid1 = shmget(SHM_KEY1, sizeof(struct boat_state), IPC_CREAT | 0666);
    shmid2 = shmget(SHM_KEY2, sizeof(struct boat_state), IPC_CREAT | 0666);
    if (shmid1 == -1 || shmid2 == -1) {
        perror("Nie uda\u0142o si\u0119 utworzy\u0107 pami\u0119ci wsp\u00f3\u0142dzielonej");
        exit(1);
    }

    boat1 = (struct boat_state *)shmat(shmid1, NULL, 0);
    boat2 = (struct boat_state *)shmat(shmid2, NULL, 0);
    if (boat1 == (void *)-1 || boat2 == (void *)-1) {
        perror("Nie uda\u0142o si\u0119 pod\u0142\u0105czy\u0107 pami\u0119ci wsp\u00f3\u0142dzielonej");
        cleanup(0);
    }

    memset(boat1, 0, sizeof(struct boat_state));
    memset(boat2, 0, sizeof(struct boat_state));
}

void init_semaphores() {
    semid1 = semget(SEM_KEY1, 1, IPC_CREAT | 0666);
    semid2 = semget(SEM_KEY2, 1, IPC_CREAT | 0666);
    if (semid1 == -1 || semid2 == -1) {
        perror("Nie uda\u0142o si\u0119 utworzy\u0107 semafor\u00f3w");
        cleanup(0);
    }

    if (semctl(semid1, 0, SETVAL, 1) == -1 || semctl(semid2, 0, SETVAL, 1) == -1) {
        perror("Nie uda\u0142o si\u0119 zainicjowa\u0107 semafor\u00f3w");
        cleanup(0);
    }
}

void create_fifos() {
    if (mkfifo(FIFO_PATH1, 0666) == -1 || mkfifo(FIFO_PATH2, 0666) == -1) {
        perror("Nie uda\u0142o si\u0119 utworzy\u0107 plik\u00f3w FIFO");
        cleanup(0);
    }
}

void handle_boat(const char *fifo_path, struct boat_state *boat, int capacity, int delay_between_trips) {
    int fifo_fd;
    char buffer[128];
    time_t last_passenger_time = time(NULL);

    printf("\u0141\u00f3d\u017a (%s) gotowa do obs\u0142ugi.\n", fifo_path);

    while (1) {
        fifo_fd = open(fifo_path, O_RDONLY);
        if (fifo_fd == -1) {
            perror("Nie uda\u0142o si\u0119 otworzy\u0107 pliku FIFO");
            sleep(1);
            continue;
        }

        printf("FIFO (%s) otwarte. Oczekiwanie na pasa\u017cer\u00f3w...\n", fifo_path);

        while (read(fifo_fd, buffer, sizeof(buffer)) > 0) {
            pid_t passenger_pid;
            sscanf(buffer, "%d", &passenger_pid);

            printf("Odczytano pasa\u017cera o PID: %d\n", passenger_pid);

            if (boat->occupied_seats < capacity) {
                boat->passengers[boat->occupied_seats++] = passenger_pid;
                printf("Pasa\u017cer %d wszed\u0142 na pok\u0142ad (%s). Liczba zaj\u0119tych miejsc: %d/%d\n", passenger_pid, fifo_path, boat->occupied_seats, capacity);

                last_passenger_time = time(NULL);

                if (boat->occupied_seats == capacity) {
                    printf("\u0141\u00f3d\u017a (%s) jest w pe\u0142ni za\u0142adowana. Odp\u0142ywamy...\n", fifo_path);
                    break;
                }
            } else {
                printf("Pasa\u017cer %d nie zosta\u0142 wpuszczony. \u0141\u00f3d\u017a (%s) jest pe\u0142na.\n", passenger_pid, fifo_path);
            }
        }

        close(fifo_fd);
        printf("Zamkni\u0119to FIFO (%s).\n", fifo_path);

        if (difftime(time(NULL), last_passenger_time) >= TIMEOUT * 60 || boat->occupied_seats == capacity) {
            printf("\u0141\u00f3d\u017a (%s) odp\u0142ywa z %d pasa\u017cerami.\n", fifo_path, boat->occupied_seats);
            sleep(TRIP_TIME * 60);
            printf("\u0141\u00f3d\u017a (%s) wr\u00f3ci\u0142a z rejsu. Pasa\u017cerowie mog\u0105 opuszcza\u0107 pok\u0142ad.\n", fifo_path);

            memset(boat, 0, sizeof(struct boat_state));
            sleep(delay_between_trips * 60);
        }
    }
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    init_shared_memory();
    init_semaphores();
    create_fifos();

    if (fork() == 0) {
        // Proces dla \u0142odzi 1
        handle_boat(FIFO_PATH1, boat1, BOAT1_CAPACITY, 30);
        exit(0);
    }

    if (fork() == 0) {
        // Proces dla \u0142odzi 2
        handle_boat(FIFO_PATH2, boat2, BOAT2_CAPACITY, 30);
        exit(0);
    }

    while (1) {
        int status;
        pid_t pid = waitpid(-1, &status, WNOHANG);
        if (pid > 0) {
            printf("Proces potomny %d zako\u0144czy\u0142 si\u0119.\n", pid);
        }
        sleep(1);
    }

    return 0;
}
